# IP包捕获与解析程序 - 用户指南

## 目录

1. [快速开始](#快速开始)
2. [程序安装](#程序安装)
3. [运行程序](#运行程序)
4. [使用示例](#使用示例)
5. [输出说明](#输出说明)
6. [常见问题](#常见问题)
7. [高级用法](#高级用法)

---

## 快速开始

### 1. 下载程序

程序包含以下文件：
```
ip_packet_analyzer/
├── ip_analyzer.cpp      # 主程序源代码
├── Makefile            # 编译配置文件
├── README.md           # 详细说明文档
└── 用户指南.md          # 本文件
```

### 2. 编译程序（30秒）

```bash
cd ip_packet_analyzer
make
```

### 3. 运行程序

```bash
sudo ./ip_analyzer
```

### 4. 选择网卡

程序会自动检测网卡，输入对应的索引号即可：
```
可用的网络设备：
索引    设备名称                描述
------------------------------------------------
0       eth0                    以太网接口
1       wlan0                   无线网络接口

请选择要监听的网卡索引号(0-9): 0
```

### 5. 查看结果

程序开始捕获IP包并显示解析结果。

---

## 程序安装

### 系统要求

#### 支持的操作系统
- **Linux**: Ubuntu 16.04+, CentOS 7+, Debian 9+, Fedora 28+
- **macOS**: 10.12 Sierra 或更高版本
- **Windows**: Windows 10 (需要Npcap)

#### 硬件要求
- **CPU**: 1GHz 或更高
- **内存**: 512MB RAM 或更高
- **网卡**: 支持混杂模式的以太网或无线网卡

### 安装依赖

#### Ubuntu/Debian 系统
```bash
# 更新软件包列表
sudo apt-get update

# 安装编译工具和依赖库
sudo apt-get install -y build-essential libpcap-dev
```

#### CentOS/RHEL 系统
```bash
# 安装编译工具和依赖库
sudo yum install -y gcc-c++ make libpcap-devel
```

#### macOS 系统
```bash
# 使用Homebrew安装libpcap
brew install libpcap
```

#### Windows 系统
1. 下载并安装 [Npcap](https://npcap.com/#download)
2. 使用 Visual Studio 或 MinGW 编译

### 编译程序

#### 方法1：使用Makefile（推荐）
```bash
cd ip_packet_analyzer
make
```

输出：
```
g++ -Wall -Wextra -std=c++11 -g -c ip_analyzer.cpp -o ip_analyzer.o
g++ ip_analyzer.o -o ip_analyzer -lpcap
编译成功！生成可执行文件: ip_analyzer
```

#### 方法2：手动编译
```bash
g++ -Wall -Wextra -std=c++11 -g ip_analyzer.cpp -o ip_analyzer -lpcap
```

#### 方法3：调试版本
```bash
g++ -Wall -Wextra -std=c++11 -g3 -DDEBUG ip_analyzer.cpp -o ip_analyzer_debug -lpcap
```

### 验证安装

```bash
# 检查文件是否存在
ls -lh ip_analyzer

# 检查程序是否可以运行
./ip_analyzer --help 2>&1 | head -5
```

---

## 运行程序

### 基本运行

#### 方法1：使用sudo（推荐）
```bash
sudo ./ip_analyzer
```

#### 方法2：设置capabilities（Linux）
```bash
# 设置网络权限
sudo setcap cap_net_raw,cap_net_admin=eip ./ip_analyzer

# 之后可以普通用户运行
./ip_analyzer
```

#### 方法3：添加用户到组（需要重新登录）
```bash
# 添加到pcap组
sudo usermod -a -G pcap $USER

# 重新登录后运行
./ip_analyzer
```

### 程序启动流程

1. **显示欢迎信息**
```
========================================
     IP包捕获与解析程序
========================================
```

2. **检测网卡设备**
```
正在检测网络设备...

可用的网络设备：
索引    设备名称                描述
------------------------------------------------
0       eth0                    以太网接口
1       wlan0                   无线网络接口
2       lo                      本地回环接口
```

3. **选择网卡**
```
请选择要监听的网卡索引号(0-9): 0
```

4. **打开网卡并设置过滤器**
```
正在打开网卡: eth0
网卡打开成功！
过滤器设置成功，只捕获IP包

开始捕获IP包... (按Ctrl+C停止)
```

5. **开始捕获和解析**
```
[包 #1]
捕获时间: Mon Dec 24 10:30:45 2025
----------------------------------------
字段名               值                      说明
----------------------------------------
版本号(Version)      4                       IPv4
首部长度(IHL)        20                      字节
总长度(Total Length) 60                      字节
...
```

### 停止程序

- **方法1**: 按 `Ctrl+C`
- **方法2**: 关闭终端窗口
- **方法3**: 发送SIGTERM信号

---

## 使用示例

### 示例1：捕获TCP包

```
[包 #1]
捕获时间: Mon Dec 24 10:30:45 2025
----------------------------------------
字段名               值                      说明
----------------------------------------
版本号(Version)      4                       IPv4
首部长度(IHL)        20                      字节
总长度(Total Length) 60                      字节
标识(Identification) 0x4a2c (18988)          
标志位(Flags)        0x2                     
                     [保留位: 0, DF(不分片): 1, MF(更多分片): 0]
片偏移(Fragment Offset) 0                    * 8 = 0 字节
协议(Protocol)       6                       (TCP)
首部校验和          0x1234                  
源IP地址(Source)     192.168.1.100
目的IP地址(Destination) 192.168.1.1

========================================
```

**说明**：这是一个TCP SYN包，从192.168.1.100发送到192.168.1.1。DF标志为1表示不允许分片。

### 示例2：捕获UDP包

```
[包 #2]
捕获时间: Mon Dec 24 10:30:46 2025
----------------------------------------
字段名               值                      说明
----------------------------------------
版本号(Version)      4                       IPv4
首部长度(IHL)        20                      字节
总长度(Total Length) 1500                    字节
标识(Identification) 0x3f1a (16154)          
标志位(Flags)        0x1                     
                     [保留位: 0, DF(不分片): 0, MF(更多分片): 1]
片偏移(Fragment Offset) 0                    * 8 = 0 字节
协议(Protocol)       17                      (UDP)
首部校验和          0x5678                  
源IP地址(Source)     8.8.8.8
目的IP地址(Destination) 192.168.1.100

========================================
```

**说明**：这是一个UDP包，从DNS服务器8.8.8.8返回的数据包。MF标志为1表示有更多分片。

### 示例3：捕获ICMP包

```
[包 #3]
捕获时间: Mon Dec 24 10:30:47 2025
----------------------------------------
字段名               值                      说明
----------------------------------------
版本号(Version)      4                       IPv4
首部长度(IHL)        20                      字节
总长度(Total Length) 84                      字节
标识(Identification) 0x5c8f (23695)          
标志位(Flags)        0x2                     
                     [保留位: 0, DF(不分片): 1, MF(更多分片): 0]
片偏移(Fragment Offset) 0                    * 8 = 0 字节
协议(Protocol)       1                       (ICMP)
首部校验和          0x9abc                  
源IP地址(Source)     192.168.1.100
目的IP地址(Destination) 8.8.8.8

========================================
```

**说明**：这是一个ICMP Echo Request包（ping请求），从本地主机发送到8.8.8.8。

### 示例4：捕获分片包

```
[包 #4]
捕获时间: Mon Dec 24 10:30:48 2025
----------------------------------------
字段名               值                      说明
----------------------------------------
版本号(Version)      4                       IPv4
首部长度(IHL)        20                      字节
总长度(Total Length) 1500                    字节
标识(Identification) 0x7b3c (31548)          
标志位(Flags)        0x1                     
                     [保留位: 0, DF(不分片): 0, MF(更多分片): 1]
片偏移(Fragment Offset) 185                  * 8 = 1480 字节
协议(Protocol)       6                       (TCP)
首部校验和          0xabcd                  
源IP地址(Source)     192.168.1.100
目的IP地址(Destination) 192.168.1.1

========================================
```

**说明**：这是一个IP分片包，片偏移为185，表示这是原始数据报的第1480字节开始的数据。

---

## 输出说明

### 输出字段详解

#### 1. 版本号 (Version)
- **字段**: IP头部的版本字段 (4位)
- **值**: 通常为4（表示IPv4）
- **说明**: 指示IP协议的版本

#### 2. 首部长度 (IHL - Internet Header Length)
- **字段**: IP头部的首部长度字段 (4位)
- **单位**: 32位字（4字节）
- **值**: 通常为5（表示20字节）
- **说明**: IP头部的长度，不包括数据部分

#### 3. 总长度 (Total Length)
- **字段**: IP头部的总长度字段 (16位)
- **单位**: 字节
- **范围**: 20-65535字节
- **说明**: 整个IP数据报的长度，包括头部和数据

#### 4. 标识 (Identification)
- **字段**: IP头部的标识字段 (16位)
- **值**: 唯一的标识符
- **说明**: 用于标识同一个数据报的不同分片

#### 5. 标志位 (Flags)
- **字段**: IP头部的标志位字段 (3位)
- **位定义**:
  - Bit 0: 保留位（必须为0）
  - Bit 1: DF (Don't Fragment) - 不分片标志
  - Bit 2: MF (More Fragments) - 更多分片标志
- **说明**: 控制IP数据报的分片行为

#### 6. 片偏移 (Fragment Offset)
- **字段**: IP头部的片偏移字段 (13位)
- **单位**: 8字节块
- **值**: 分片在原始数据报中的位置
- **说明**: 指示该分片相对于原始数据报开始处的位置

#### 7. 协议 (Protocol)
- **字段**: IP头部的协议字段 (8位)
- **常见值**:
  - 1: ICMP
  - 6: TCP
  - 17: UDP
  - 89: OSPF
- **说明**: 指示上层使用的协议

#### 8. 首部校验和 (Header Checksum)
- **字段**: IP头部的校验和字段 (16位)
- **值**: 校验和值
- **说明**: 用于检验IP头部在传输过程中是否损坏

#### 9. 源IP地址 (Source IP)
- **字段**: IP头部的源地址字段 (32位)
- **格式**: 点分十进制（如192.168.1.100）
- **说明**: 发送方的IP地址

#### 10. 目的IP地址 (Destination IP)
- **字段**: IP头部的目的地址字段 (32位)
- **格式**: 点分十进制（如8.8.8.8）
- **说明**: 接收方的IP地址

### 输出格式

程序使用表格格式输出，包含以下列：

| 列名 | 宽度 | 说明 |
|------|------|------|
| 字段名 | 20字符 | IP头部字段的名称 |
| 值 | 25字符 | 字段的值（十六进制或十进制） |
| 说明 | 可变 | 字段的含义和解释 |

### 特殊标记

#### 十六进制值
- 以 `0x` 开头
- 例如：`0x4a2c` (18988)

#### 标志位解释
- 显示在值的下一行
- 格式：`[保留位: X, DF: X, MF: X]`

#### 片偏移计算
- 显示原始值和计算后的字节偏移
- 格式：`XXX * 8 = YYY 字节`

---

## 常见问题

### 问题1：编译失败

**错误信息**：
```
error: pcap.h: No such file or directory
```

**原因**：缺少libpcap开发库

**解决方案**：
```bash
# Ubuntu/Debian
sudo apt-get install libpcap-dev

# CentOS/RHEL
sudo yum install libpcap-devel
```

### 问题2：权限不足

**错误信息**：
```
错误：无法打开网卡 - 权限不足
```

**原因**：普通用户没有权限访问网卡

**解决方案**：
```bash
# 方法1：使用sudo
sudo ./ip_analyzer

# 方法2：设置capabilities
sudo setcap cap_net_raw,cap_net_admin=eip ./ip_analyzer
```

### 问题3：找不到网卡

**错误信息**：
```
未找到网络设备！
```

**原因**：
1. 没有管理员权限
2. 没有活动的网络接口
3. 在虚拟机中网络配置不正确

**解决方案**：
```bash
# 检查网卡
ip link show

# 启用网卡
sudo ip link set eth0 up

# 虚拟机中配置桥接网络
```

### 问题4：捕获不到包

**现象**：程序运行正常，但没有捕获到任何包

**原因**：
1. 选择的网卡没有流量
2. 过滤器设置过于严格
3. 网络接口处于静默状态

**解决方案**：
```bash
# 检查网卡是否有流量
sudo tcpdump -i eth0

# 尝试其他网卡
sudo ./ip_analyzer
# 选择不同的网卡索引

# 生成测试流量
ping 8.8.8.8
curl http://example.com
```

### 问题5：解析结果异常

**现象**：字段值显示不正确

**原因**：
1. 字节序转换错误
2. 字段解析错误
3. 数据包损坏

**解决方案**：
- 检查程序版本是否为最新
- 对比tcpdump的输出验证
- 使用测试程序验证：
```bash
make -f Makefile.test
./test_packet_parser
```

### 问题6：程序崩溃

**现象**：运行时出现段错误

**原因**：
1. 空指针访问
2. 缓冲区溢出
3. 权限问题

**解决方案**：
```bash
# 使用调试版本
g++ -g3 ip_analyzer.cpp -o ip_analyzer_debug -lpcap

# 使用gdb调试
gdb ./ip_analyzer_debug
(gdb) run
(gdb) bt
```

---

## 高级用法

### 1. 修改过滤器

编辑 `ip_analyzer.cpp`，修改以下行：
```cpp
const char *filter_exp = "ip";  // 默认只捕获IP包
```

**常用过滤器示例**：

```cpp
// 只捕获TCP包
const char *filter_exp = "tcp";

// 只捕获UDP包
const char *filter_exp = "udp";

// 只捕获ICMP包
const char *filter_exp = "icmp";

// 捕获特定主机的包
const char *filter_exp = "host 192.168.1.100";

// 捕获特定端口的包
const char *filter_exp = "port 80";

// 捕获特定网段的包
const char *filter_exp = "net 192.168.1.0/24";

// 复杂过滤器
const char *filter_exp = "tcp and port 80 and host 192.168.1.100";
```

### 2. 保存捕获结果

修改程序，添加保存功能：

```cpp
#include <fstream>

// 全局变量
ofstream output_file;

// 在main函数中打开文件
output_file.open("capture_log.txt", ios::app);

// 在packet_handler中添加
output_file << "[包 #" << packet_count << "]" << endl;
output_file << "源IP: " << packet_info.source_ip << endl;
output_file << "目的IP: " << packet_info.dest_ip << endl;
output_file << "协议: " << get_protocol_name(packet_info.protocol) << endl;
output_file << endl;

// 程序结束时关闭文件
output_file.close();
```

### 3. 统计功能

添加统计功能：

```cpp
// 全局变量
map<string, int> ip_counter;
map<uint8_t, int> protocol_counter;
int total_packets = 0;

// 在packet_handler中添加
void packet_handler(u_char *user_data, const struct pcap_pkthdr* pkthdr, const u_char* packet) {
    total_packets++;
    
    // 统计源IP
    ip_counter[packet_info.source_ip]++;
    
    // 统计协议
    protocol_counter[packet_info.protocol]++;
    
    // ... 其他处理
}

// 打印统计信息
void print_statistics() {
    cout << "\n=== 统计信息 ===" << endl;
    cout << "总包数: " << total_packets << endl;
    
    cout << "\n协议分布:" << endl;
    for (auto& p : protocol_counter) {
        cout << get_protocol_name(p.first) << ": " << p.second << endl;
    }
    
    cout << "\nTop 10 源IP:" << endl;
    vector<pair<string, int>> sorted_ips(ip_counter.begin(), ip_counter.end());
    sort(sorted_ips.begin(), sorted_ips.end(), 
         [](const auto& a, const auto& b) { return a.second > b.second; });
    
    for (int i = 0; i < min(10, (int)sorted_ips.size()); ++i) {
        cout << sorted_ips[i].first << ": " << sorted_ips[i].second << endl;
    }
}
```

### 4. 实时图表

使用第三方库生成实时图表：

```cpp
// 安装 ncurses 库
sudo apt-get install libncurses5-dev

// 在程序中添加
#include <ncurses.h>

void init_screen() {
    initscr();
    cbreak();
    noecho();
    nodelay(stdscr, TRUE);
}

void update_screen(const IPPacketInfo& packet_info) {
    move(0, 0);
    printw("IP包捕获实时统计\n");
    printw("总包数: %d\n", packet_count);
    printw("最新包: %s -> %s [%s]\n", 
           packet_info.source_ip, 
           packet_info.dest_ip,
           get_protocol_name(packet_info.protocol).c_str());
    refresh();
}
```

### 5. 远程监控

使用socket将捕获的数据发送到远程服务器：

```cpp
#include <sys/socket.h>
#include <netinet/in.h>

// 创建UDP socket
int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
struct sockaddr_in server_addr;
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(9999);
inet_pton(AF_INET, "192.168.1.200", &server_addr.sin_addr);

// 发送数据
char buffer[1024];
snprintf(buffer, sizeof(buffer), 
         "{\"src\":\"%s\",\"dst\":\"%s\",\"proto\":%d,\"len\":%d}\n",
         packet_info.source_ip, packet_info.dest_ip,
         packet_info.protocol, packet_info.total_length);
sendto(sockfd, buffer, strlen(buffer), 0, 
       (struct sockaddr*)&server_addr, sizeof(server_addr));
```

### 6. 性能优化

#### 使用多线程
```cpp
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>

// 工作队列
queue<PacketData> packet_queue;
mutex queue_mutex;
condition_variable cv;

// 捕获线程
void capture_thread() {
    pcap_loop(handle, -1, packet_handler, NULL);
}

// 处理线程
void process_thread() {
    while (true) {
        unique_lock<mutex> lock(queue_mutex);
        cv.wait(lock, []{ return !packet_queue.empty(); });
        
        PacketData packet = packet_queue.front();
        packet_queue.pop();
        lock.unlock();
        
        // 处理包
        process_packet(packet);
    }
}

// 主函数
int main() {
    thread cap_thread(capture_thread);
    thread proc_thread(process_thread);
    
    cap_thread.join();
    proc_thread.join();
    
    return 0;
}
```

#### 使用零拷贝
```cpp
// 使用pcap_next而不是pcap_loop
while (true) {
    struct pcap_pkthdr* header;
    const u_char* packet;
    
    int res = pcap_next_ex(handle, &header, &packet);
    if (res == 1) {
        // 直接处理，不复制数据
        process_packet(header, packet);
    }
}
```

---

## 技术支持

### 获取帮助

1. **查看文档**：README.md
2. **运行测试**：make -f Makefile.test && ./test_packet_parser
3. **检查日志**：查看程序输出

### 报告问题

如果遇到问题，请提供以下信息：

1. **系统信息**：
```bash
uname -a
cat /etc/os-release
g++ --version
```

2. **错误信息**：完整的错误输出

3. **复现步骤**：如何重现问题

4. **调试信息**：
```bash
gdb ./ip_analyzer
(gdb) run
(gdb) bt
```

### 更新日志

#### v1.0.0 (2025-12-24)
- ✨ 初始版本发布
- ✨ 支持IP包捕获和解析
- ✨ 支持版本号、总长度、标识、标志位、片偏移、协议、源地址、目的地址解析
- ✨ 友好的表格输出格式
- ✨ 自动检测网卡设备
- ✨ 支持BPF过滤器

---

## 许可协议

本程序仅供学习和研究使用。

---

*本指南最后更新：2025-12-24*
